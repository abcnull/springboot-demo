# 应用服务 WEB 访问端口
server:
  port: 8080

# 数据源配置
spring:
  application:
    name: springboot-demo
  # mysql db
  datasource:
    url: jdbc:mysql://localhost:3306/springboot_demo_db?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&useSSL=false
    username: root
    password: 123456
    # mysql 驱动
    # com.mysql.cj.jdbc.Driver 支持 mysql 8，也兼容 5.x。默认开启 SSL 连接。对时区的处理更为严格
    # com.mysql.jdbc.Driver 支持 5.x，已被弃用
    driver-class-name: com.mysql.cj.jdbc.Driver
  # redis lettuce 连接池
  redis:
    host: localhost  # Redis 服务器地址
    port: 6379       # Redis 服务器端口，默认是 6379
    password:        # Redis 密码（如果没有密码，可以省略）
    database: 0      # 使用的数据库索引，默认是 0
    timeout: 2000    # 连接超时时间（毫秒）
    lettuce:
      pool:
        max-active: 8      # 连接池最大连接数（包括正在使用和空闲的连接），根据 CPU 核心数调整，通常为 CPU * 2 + 2，默认值 8
        max-idle: 8        # 连接池最大空闲连接数（避免频繁创建连接），一般 CPU * 2，默认值 8
        min-idle: 0        # 连接池最小空闲连接数（保持一定数量的空闲连接），0 或 1（低负载场景），默认值 0
        max-wait: 5000ms     # 获取连接的最大等待时间（-1 表示无限制）（单位：毫秒，负值表示无限等待），推家 5000~60000（避免线程长时间阻塞），默认值 -1
  # kafka 接入
  kafka:
    bootstrap-servers: localhost:9092 # kafka 连接地址
    # 生产者配置
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer # 对于复杂对象，使用JsonSerializer和JsonDeserializer，避免使用默认的StringSerializer处理JSON数据
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      # 批量发送配置
      batch-size: 16384
      linger: 5ms
    # 消费者配置
    consumer:
      group-id: my-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
    # 监听器配置
    listener:
      concurrency: 3  # 消费者并发数
      ack-mode: manual_immediate
  #    # 如果要手动提交偏移量来确认消息消费掉，需要改成下面方式！否则走默认的自动 5s 后提交偏移量来自动确认消息已经消费，让下次该消息不再发送
  #    consumer:
  #      enable-auto-commit: false
  #      group-id: my-group
  #    listener:
  #      ack-mode: MANUAL  # 关键配置！

  # ⬇️ 因为 mongodb 服务端没有启动，这里注释掉，否则会报错，当你存在 mongo 服务端，你这里会要开放并做好配置
#  # mongodb
#  data:
#    mongodb:
#      uri: mongodb://app-user:${MONGODB_PASSWORD}@mongo-prod.example.com:27017/mydb?ssl=true&authSource=admin&retryWrites=true&retryReads=true&applicationName=production-app-springboot-demo
#      host: mongo-prod.example.com
#      port: 27017
#      database: mydb
#      username: app-user
#      password: "strongPassword123!"
#      authentication-database: admin

  # ⬇️ 因为 es 服务端没有启动，这里注释掉，否则会报错，当你存在 es 服务端，你这里会要开放并做好配置
#  # elasticsearch
#  elasticsearch:
#    uris: http://localhost:9200
#    username: elastic
#    password: your_secure_password

  # Hive 数据源配置
  hive:
    url: jdbc:hive2://your-hive-server:10000/default
    username: hive
    password: hive123
    driver-class-name: org.apache.hive.jdbc.HiveDriver

  # Hbase
  hbase:
    zookeeper:
      quorum: zk1.example.com,zk2.example.com,zk3.example.com
      property:
        clientPort: 2181
    znode:
      parent: /hbase

  # clickhouse
  clickhouse:
    # 推荐：直接在URL中包含认证信息
    url: jdbc:clickhouse://your-clickhouse-server:8123/your_database?user=default&password=your_password&socket_timeout=60000&connection_timeout=30000

  # ⬇️ 因为 sso 授权中心没有启动，这里注释掉，否则会报错，当你存在 sso 授权中心，你这里会要开放并做好配置
#  # sso 配置
#  security:
#    oauth2:
#      client:
#        registration:
#          keycloak: # 可以是任何 OAuth2 提供者如 azure、okta、自定义等
#            client-id: ${SSO_CLIENT_ID:my-app-client-id} # 客户端 ID
#            client-secret: ${SSO_CLIENT_SECRET:my-app-client-secret} # 客户端密钥
#            redirect-uri: "{baseUrl}/login/oauth2/code/keycloak" # keycloak 验证用户在登录界面输出的密码后，让 browser 重定向的地址
#            authorization-grant-type: authorization_code
#            scope: openid,profile,email,roles
#        provider:
#          keycloak:
#            issuer-uri: ${SSO_ISSUER_URI:http://auth.example.com/auth/realms/my-realm} # 认证中心地址
#            user-name-attribute: preferred_username
## 应用特定配置
#app:
#  security:
#    # 登出后重定向到SSO登出端点，实现全局登出
#    logout-success-url: ${SSO_LOGOUT_URL:http://auth.example.com/auth/realms/my-realm/protocol/openid-connect/logout?redirect_uri={baseUrl}}

# 下面这些内容是为了让 MyBatis 映射
mybatis:
  # 指定 Mybatis 的 Mapper xml 文件在 resources 下的位置
  # 默认是 resources 下的 com.example.springbootdemo.mapper 下，因为与 mapper 接口路径对应
  # 由于一般包名较长，习惯直接放在 resources 下的 mapper 文件中
  mapper-locations: classpath:mapper/*xml
  # 指定 Mybatis 的实体所在的目录
  type-aliases-package: org.example.springbootdemo.model

# 分页插件
pagehelper:
  # 指定数据库方言
  helper-dialect: mysql
  # 启用分页合理化
  reasonable: true
  # 支持通过 Mapper 方法参数传递分页参数
  support-methods-arguments: true
  # 看情况加
  # 允许通过自定义的 SQL 查询语句来计算总记录数，而不是依赖 PageHelper 自动生成的 COUNT 查询，主要起到优化性能的作用
  params: count=countSql
  # 看情况加
  # true 表示：当 pageSize=0 或 RowBounds.limit=0 时，查询全部结果
  page-size-zero: false

# ⬇️ 因为 eureka 服务端没有启动，这里注释掉，否则会报错，当你存在 eureka 服务端，你这里要开放并做好配置
## 服务注册中心（要连接到注册中心，为了调用微服务，和向注册中心注册自身服务）
#eureka:
#  client:
#    service-url:
#      defaultZone: http://localhost:8761/eureka/

# springboot 自带的 logback 的日志配置
logging:
  config: classpath:logback-spring.xml
